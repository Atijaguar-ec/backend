// ============================================================================
// Pipeline de Despliegue Backend - Fortaleza del Valle
// Autor: Alvaro Sanchez
// Ãšltima actualizaciÃ³n: 2025-10-09 v2.1
// ============================================================================

pipeline {
  agent any

  options {
    skipDefaultCheckout(true)
    timeout(time: 40, unit: 'MINUTES')
    ansiColor('xterm')
    buildDiscarder(logRotator(numToKeepStr: '30', artifactNumToKeepStr: '10'))
    disableConcurrentBuilds()
    timestamps()
  }

  parameters {
    choice(
      name: 'BRANCH',
      choices: ['staging', 'main'],
      description: 'Rama a desplegar (stagingâ†’test, mainâ†’prod)'
    )
    booleanParam(
      name: 'SKIP_TESTS',
      defaultValue: false,
      description: 'âš ï¸ Omitir pruebas (no recomendado para producciÃ³n)'
    )
    booleanParam(
      name: 'SKIP_DB_BACKUP',
      defaultValue: false,
      description: 'âš ï¸ Omitir backup de BD en producciÃ³n (no recomendado para producciÃ³n)' 
    )
    string(
      name: 'PROD_HOST_PRIMARY',
      defaultValue: '',
      description: 'Hostname o IP del servidor de producciÃ³n principal (ej. prod-fortaleza.atijaguar.com)'
    )
    string(
      name: 'PROD_USER_PRIMARY',
      defaultValue: 'deploy',
      description: 'Usuario SSH para el servidor de producciÃ³n principal'
    )
    string(
      name: 'PROD_TARGET_PRIMARY',
      defaultValue: '/opt/inatrace/backend/prod/fortaleza',
      description: 'Directorio remoto donde se desplegarÃ¡ la app en el servidor principal'
    )
    string(
      name: 'PROD_HEALTH_PORT_PRIMARY',
      defaultValue: '8082',
      description: 'Puerto local donde expone healthcheck el backend en el servidor principal'
    )
    string(
      name: 'PROD_HEALTH_URL_PRIMARY',
      defaultValue: 'https://inatrace.espam.edu.ec/api/actuator/health',
      description: 'URL externa para validar healthcheck del servidor principal'
    )
    string(
      name: 'PROD_HOST_SECONDARY',
      defaultValue: '',
      description: 'Hostname o IP del nuevo servidor de producciÃ³n (dejar vacÃ­o para omitir)'
    )
    string(
      name: 'PROD_USER_SECONDARY',
      defaultValue: 'deploy',
      description: 'Usuario SSH para el nuevo servidor de producciÃ³n'
    )
    string(
      name: 'PROD_TARGET_SECONDARY',
      defaultValue: '/opt/inatrace/backend/prod/fortaleza-secondary',
      description: 'Directorio remoto donde se desplegarÃ¡ la app en el nuevo servidor'
    )
    string(
      name: 'PROD_HEALTH_PORT_SECONDARY',
      defaultValue: '8082',
      description: 'Puerto local donde expone healthcheck el backend en el nuevo servidor'
    )
    string(
      name: 'PROD_HEALTH_URL_SECONDARY',
      defaultValue: '',
      description: 'URL externa opcional para validar healthcheck del nuevo servidor'
    )
  }

  environment {
    // ConfiguraciÃ³n de registro Docker
    REGISTRY = 'ghcr.io'
    
    // ConfiguraciÃ³n de despliegue
    COMPOSE_PROJECT_NAME = 'inatrace-backend-fortaleza'
    DOCKER_BUILDKIT = '1'
    COMPOSE_DOCKER_CLI_BUILD = '1'
    
    // Timeouts y reintentos
    HEALTH_CHECK_TIMEOUT = '120'
    HEALTH_CHECK_INTERVAL = '10'
    MAX_RETRIES = '3'
  }


  tools {
    jdk 'jdk-17'
    maven 'maven-3.9.11'
  }

  stages {
    // ========================================================================
    // STAGE 0: Checkout cÃ³digo fuente backend
    // ========================================================================
    stage('ğŸ“¥ Checkout') {
      steps {
        cleanWs()
        checkout([
          $class: 'GitSCM',
          branches: [[name: "*/${params.BRANCH}"]],
          userRemoteConfigs: [[
            url: 'https://github.com/Atijaguar-ec/backend.git',
            credentialsId: 'github-pat'
          ]],
          extensions: [
            [$class: 'CloneOption', shallow: false, depth: 0, noTags: false]
          ]
        ])
      }
    }

    // ========================================================================
    // STAGE 1: InicializaciÃ³n y configuraciÃ³n
    // ========================================================================
    stage('ğŸ”§ InicializaciÃ³n') {
      steps {
        script {
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  INICIO DE DESPLIEGUE - FORTALEZA DEL VALLE"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "Rama: ${params.BRANCH}"
          echo "Usuario: ${env.BUILD_USER ?: 'Sistema'}"
          echo "Timestamp: ${new Date().format('yyyy-MM-dd HH:mm:ss z')}"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        }
        
        script {
          // Extraer informaciÃ³n del repositorio (ya clonado por SCM)
          def remoteUrl = sh(script: 'git config --get remote.origin.url', returnStdout: true).trim()
          remoteUrl = remoteUrl.replaceAll(/\.git$/, '')
          remoteUrl = remoteUrl.replaceFirst(/^https?:\/\/github.com\//, '')
          remoteUrl = remoteUrl.replaceFirst(/^git@github.com:/, '')
          
          env.REPO_FULL_NAME = remoteUrl
          env.GIT_SHORT_SHA = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
          env.GIT_COMMIT_MSG = sh(script: 'git log -1 --pretty=%B', returnStdout: true).trim()
          env.GIT_AUTHOR = sh(script: 'git log -1 --pretty=%an', returnStdout: true).trim()
          // Configurar variables segÃºn entorno
          env.IMAGE_REPOSITORY = env.REGISTRY.toLowerCase() + '/' + (env.REPO_FULL_NAME + '-inatrace').toLowerCase()
          env.DEPLOY_TAG = params.BRANCH == 'main' ? 'latest' : "test-${env.GIT_SHORT_SHA}"
          env.FORTALEZA_ENV = params.BRANCH == 'main' ? 'prod' : 'test'
          env.HEALTHCHECK_URL = params.BRANCH == 'main' ? 
            'https://inatrace.espam.edu.ec/api/actuator/health' : 
            'https://testinatrace.espam.edu.ec/api/actuator/health'
          env.PROJECT_DIR = fileExists('backend/pom.xml') ? 'backend' : '.'
          env.COMPOSE_DIR = fileExists('backend/ci/docker-compose.yml') ? 'backend/ci' : 'ci'
          
          echo "\nğŸ“¦ InformaciÃ³n del Build :"
          echo "  - Repositorio: ${env.REPO_FULL_NAME}"
          echo "  - Commit: ${env.GIT_SHORT_SHA}"
          echo "  - Autor: ${env.GIT_AUTHOR}"
          echo "  - Mensaje: ${env.GIT_COMMIT_MSG}"
          echo "  - Imagen: ${env.IMAGE_REPOSITORY}:${env.DEPLOY_TAG}"
          echo "  - Entorno: ${env.FORTALEZA_ENV}"
        }
      }
    }

    // ========================================================================
    // STAGE 2: Pruebas y ValidaciÃ³n de Calidad
    // ========================================================================
    stage('ğŸ§ª Tests & Quality') {
      when {
        expression { return !params.SKIP_TESTS }
      }
      steps {
        script {
          echo "\nğŸ§ª Ejecutando pruebas unitarias e integraciÃ³n..."
          if (params.BRANCH == 'main' && params.SKIP_TESTS) {
            error("âŒ No se permiten despliegues a producciÃ³n sin pruebas")
          }
        }
        
        script {
          def mysqlContainer = 'inatrace-mysql-ci'
          sh """
            set -e
            echo "ğŸ§¹ Preparando contenedor MySQL temporal..."
            docker rm -f ${mysqlContainer} >/dev/null 2>&1 || true
            docker run -d --name ${mysqlContainer} \
              -e MYSQL_ROOT_PASSWORD=inatrace \
              -e MYSQL_DATABASE=inatrace \
              -e MYSQL_USER=inatrace \
              -e MYSQL_PASSWORD=inatrace \
              -p 3307:3306 \
              mysql:8.0.35
          """

          sh '''
            set +e
            echo "â³ Esperando disponibilidad de MySQL temporal..."
            for i in $(seq 1 12); do
              if docker exec inatrace-mysql-ci sh -c "mysqladmin ping -h127.0.0.1 -uroot -pinatrace" >/dev/null 2>&1; then
                exit 0
              fi
              echo "Intento ${i}/12..."
              sleep 5
            done
            echo "âŒ MySQL temporal no disponible" >&2
            exit 1
          '''

          dir('.') {
            sh """
              set -e
              PROJECT_DIR='${env.PROJECT_DIR}'
              if [ "${env.PROJECT_DIR}" = 'backend' ]; then
                cd backend
              fi

              echo "ğŸ“Š Ejecutando Maven verify..."
              SPRING_DATASOURCE_URL="jdbc:mysql://127.0.0.1:3307/inatrace" \
              SPRING_DATASOURCE_USERNAME="inatrace" \
              SPRING_DATASOURCE_PASSWORD="inatrace" \
              mvn -B clean verify \
                -Dspring.profiles.active=test \
                -Dmaven.test.failure.ignore=false \
                -Djacoco.skip=false

              echo "âœ… Pruebas completadas exitosamente"
            """
          }
        }
      }
      post {
        always {
          junit allowEmptyResults: true, testResults: '**/target/surefire-reports/*.xml'
          sh 'docker rm -f inatrace-mysql-ci >/dev/null 2>&1 || true'
        }
        failure {
          echo "âŒ Las pruebas fallaron. Abortando despliegue."
        }
      }
    }

    // ========================================================================
    // STAGE 3: ConstrucciÃ³n y PublicaciÃ³n de Imagen Docker
    // ========================================================================
    stage('ğŸ—ï¸ Build & Push Image') {
      steps {
        script {
          echo "\nğŸ—ï¸ Construyendo imagen Docker..."
        }
        
        withCredentials([
          usernamePassword(credentialsId: 'ghcr-credentials', usernameVariable: 'GHCR_USER', passwordVariable: 'GHCR_TOKEN')
        ]) {
          sh """
            set -e

            PROJECT_DIR='${env.PROJECT_DIR}'
            if [ "${env.PROJECT_DIR}" = 'backend' ]; then
              cd backend
            fi

            echo "ğŸ” Autenticando en GHCR..."
            echo \$GHCR_TOKEN | docker login ghcr.io -u \$GHCR_USER --password-stdin

            echo "ğŸ“¦ Compilando artefactos con Maven..."
            mvn -B clean package -DskipTests -Dmaven.javadoc.skip=true

            echo "ğŸ³ Construyendo imagen Docker..."
            docker build \
              --build-arg BUILD_DATE=\$(date -u +"%Y-%m-%dT%H:%M:%SZ") \
              --build-arg VCS_REF=${GIT_SHORT_SHA} \
              --build-arg VERSION=${DEPLOY_TAG} \
              --label "org.opencontainers.image.created=\$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
              --label "org.opencontainers.image.revision=${GIT_SHORT_SHA}" \
              --label "org.opencontainers.image.version=${DEPLOY_TAG}" \
              --label "org.opencontainers.image.source=https://github.com/${REPO_FULL_NAME}" \
              -t ${IMAGE_REPOSITORY}:${DEPLOY_TAG} \
              .

            echo "ğŸ“¤ Publicando imagen con tag: ${DEPLOY_TAG}"
            docker push ${IMAGE_REPOSITORY}:${DEPLOY_TAG}

            echo "ğŸ·ï¸ Etiquetando como latest..."
            docker tag ${IMAGE_REPOSITORY}:${DEPLOY_TAG} ${IMAGE_REPOSITORY}:latest
            docker push ${IMAGE_REPOSITORY}:latest

            echo "âœ… Imagen publicada exitosamente"
            docker images | grep ${IMAGE_REPOSITORY} | head -5
          """
        }
      }
      post {
        failure {
          echo "âŒ FallÃ³ la construcciÃ³n o publicaciÃ³n de la imagen"
        }
      }
    }

    // ========================================================================
    // STAGE 4: Backup de Base de Datos (solo producciÃ³n)
    // ========================================================================
    stage('ğŸ’¾ Database Backup') {
      when {
        allOf {
          expression { params.BRANCH == 'main' }
          expression { !params.SKIP_DB_BACKUP }
        }
      }
      steps {
        script {
          echo "\nğŸ’¾ Realizando backup de base de datos..."
          sh '''
            set -e
            CONTAINER_NAME="inatrace-mysql-prod-fortaleza"
            BACKUP_DIR="/opt/inatrace/backups"
            BACKUP_FILE="backup-$(date +%Y%m%d-%H%M%S)-pre-deploy.sql.gz"
            
            if docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
              echo "ğŸ“¦ Creando backup en: ${BACKUP_DIR}/${BACKUP_FILE}"
              docker exec "${CONTAINER_NAME}" sh -c '
                mysqldump -u root -p"${MYSQL_ROOT_PASSWORD}" \
                  --single-transaction \
                  --quick \
                  --lock-tables=false \
                  "${MYSQL_DATABASE}" | gzip -9 > "/backups/'"${BACKUP_FILE}"'"
              '
              
              echo "ğŸ§¹ Limpiando backups antiguos (>14 dÃ­as)..."
              docker exec "${CONTAINER_NAME}" sh -c '
                find /backups -name "backup-*.sql.gz" -mtime +14 -delete
              '
              
              echo "âœ… Backup completado: ${BACKUP_FILE}"
            else
              echo "âš ï¸ Contenedor MySQL no encontrado, omitiendo backup"
            fi
          '''
        }
      }
    }
    
    // ========================================================================
    // STAGE 5: Despliegue en Fortaleza
    // ========================================================================
    stage('ğŸš€ Deploy Fortaleza') {
      steps {
        script {
          echo "\nğŸš€ Iniciando despliegue en entorno: ${env.FORTALEZA_ENV}"

          def envCredential = env.FORTALEZA_ENV == 'prod' ? 'fortaleza-env-prod' : 'fortaleza-env-staging'

          dir(env.COMPOSE_DIR) {
            withCredentials([file(credentialsId: envCredential, variable: 'ENVFILE')]) {
              sh '''
                set -e

                echo "ğŸ“‹ Preparando archivo .env..."
                cp $ENVFILE .env

                echo "ğŸ“ Verificando docker-compose.yml..."
                if [ ! -f docker-compose.yml ]; then
                  if [ -f ../docker-compose.yml ]; then
                    cp ../docker-compose.yml ./docker-compose.yml
                  elif [ -f ../../ci/docker-compose.yml ]; then
                    cp ../../ci/docker-compose.yml ./docker-compose.yml
                  else
                    echo "âŒ No se encontrÃ³ docker-compose.yml en rutas previstas" >&2
                    exit 1
                  fi
                else
                  echo "âœ… docker-compose.yml presente en ${PWD}"
                fi

                echo "ğŸ› ï¸ Actualizando variables dinÃ¡micas en .env..."
                ensure_var() {
                  local key="$1"
                  local value="$2"
                  if grep -q "^${key}=" .env; then
                    sed -i "s|^${key}=.*|${key}=${value}|" .env
                  else
                    printf '\n%s=%s' "$key" "$value" >> .env
                  fi
                }

                ensure_var TAG "${DEPLOY_TAG}"
                ensure_var IMAGE_NAME "${IMAGE_REPOSITORY}"
                echo "âœ… Archivo .env actualizado"
                
                echo "\nğŸ”— Verificando red Docker..."
                docker network inspect inatrace-backend-network >/dev/null 2>&1 || \
                  docker network create inatrace-backend-network
                
                echo "\nğŸ“¥ Descargando Ãºltima imagen..."
                docker-compose pull || true
                
                echo "\nğŸ”„ Desplegando servicios..."
                docker-compose up -d --remove-orphans --force-recreate
                
                echo "\nğŸ“Š Estado de contenedores:"
                docker-compose ps
                
                echo "\nâ³ Esperando que el backend estÃ© saludable..."
                RETRY_COUNT=0
                MAX_RETRIES=12
                SLEEP_TIME=10
                
                while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                  RETRY_COUNT=$((RETRY_COUNT + 1))
                  
                  if curl -fsS --max-time 5 "${HEALTHCHECK_URL}" >/dev/null 2>&1; then
                    echo "âœ… Backend Fortaleza estÃ¡ saludable"
                    echo "\nğŸ“ˆ Logs recientes:"
                    docker-compose logs --tail=20 inatrace-be
                    exit 0
                  fi
                  
                  echo "â³ Intento ${RETRY_COUNT}/${MAX_RETRIES} - Esperando ${SLEEP_TIME}s..."
                  sleep $SLEEP_TIME
                done
                
                echo "\nâŒ Health check fallÃ³ despuÃ©s de ${MAX_RETRIES} intentos" >&2
                echo "\nğŸ“‹ Logs del contenedor:"
                docker-compose logs --tail=50 inatrace-be
                echo "\nğŸ“Š Estado de contenedores:"
                docker-compose ps
                exit 1
              '''
            }
          }

          if (params.BRANCH == 'main' && params.PROD_HOST_SECONDARY?.trim()) {
            sh """
              set -e

              echo "\nğŸš€ Repitiendo despliegue en servidor secundario: ${params.PROD_HOST_SECONDARY}"

              SSH_FLAGS="${params.PROD_USER_SECONDARY}@${params.PROD_HOST_SECONDARY}"

              scp ${env.COMPOSE_DIR}/docker-compose.yml ${SSH_FLAGS}:${params.PROD_TARGET_SECONDARY}/docker-compose.yml
              scp ${env.COMPOSE_DIR}/.env ${SSH_FLAGS}:${params.PROD_TARGET_SECONDARY}/.env

              ssh ${SSH_FLAGS} <<'EOSSH'
set -e
cd ${params.PROD_TARGET_SECONDARY}

echo "ğŸ”— Verificando red Docker..."
docker network inspect inatrace-backend-network >/dev/null 2>&1 || docker network create inatrace-backend-network

echo "ğŸ“¥ Descargando Ãºltima imagen..."
docker-compose pull || true

echo "ğŸ”„ Desplegando servicios..."
docker-compose up -d --remove-orphans --force-recreate

echo "â³ Esperando healthcheck local..."
RETRY_COUNT=0
MAX_RETRIES=12
while [ ${'$'}RETRY_COUNT -lt ${'$'}MAX_RETRIES ]; do
  RETRY_COUNT=${'$'}((RETRY_COUNT + 1))
  if curl -fsS --max-time 5 "http://localhost:${params.PROD_HEALTH_PORT_SECONDARY}/actuator/health" >/dev/null 2>&1; then
    echo "âœ… Backend secundario saludable"
    exit 0
  fi
  echo "â³ Intento ${'$'}RETRY_COUNT/${'$'}MAX_RETRIES..."
  sleep 10
done

echo "âŒ Healthcheck fallÃ³ en servidor secundario" >&2
docker-compose logs --tail=50 inatrace-be
docker-compose ps
exit 1
EOSSH

              if [ -n "${params.PROD_HEALTH_URL_SECONDARY?.trim()}" ]; then
                echo "ğŸŒ Verificando health externo secundario: ${params.PROD_HEALTH_URL_SECONDARY}"
                curl -fsS "${params.PROD_HEALTH_URL_SECONDARY}" || {
                  echo "âŒ Health externo fallÃ³" >&2
                  exit 1
                }
              fi
            """
          }
        }
      }
      post {
        success {
          script {
            echo "\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "  âœ… DESPLIEGUE EXITOSO - ${env.FORTALEZA_ENV.toUpperCase()}"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "Imagen: ${env.IMAGE_REPOSITORY}:${env.DEPLOY_TAG}"
            echo "Commit: ${env.GIT_SHORT_SHA}"
            echo "URL: ${env.HEALTHCHECK_URL}"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          }
        }
        failure {
          script {
            echo "\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "  âŒ DESPLIEGUE FALLIDO"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "Revisa los logs arriba para mÃ¡s detalles"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          }
        }
      }
    }
  }
  
  post {
    always {
      script {
        echo "\nğŸ§¹ Limpieza post-despliegue..."
        sh '''
          # Logout de registros Docker
          docker logout ghcr.io || true
          
          # Limpiar imÃ¡genes huÃ©rfanas (opcional)
          docker image prune -f --filter "dangling=true" || true
        '''
      }
    }
    success {
      script {
        def duration = currentBuild.durationString.replace(' and counting', '')
        echo "\nğŸ‰ Pipeline completado exitosamente en ${duration}"
      }
    }
    failure {
      script {
        echo "\nâŒ Pipeline fallÃ³. Revisa los logs para mÃ¡s informaciÃ³n."
        // AquÃ­ puedes agregar notificaciones (Slack, email, etc.)
      }
    }
    unstable {
      echo "\nâš ï¸ Pipeline completado con advertencias"
    }
  }
}